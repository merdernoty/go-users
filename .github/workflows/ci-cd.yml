name: ci-cd

on:
  push:
    branches: [ "main" ]
    tags: [ "v*" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}
  GO_VERSION: "1.24.x"
  CGO_ENABLED: "0"
  GOOS: linux
  GOARCH: amd64

jobs:
  docker:
    name: Build & Push (${{ matrix.service.name }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service:
          - { name: "users",        path: "users",        dockerfile: "users/Dockerfile" }
          - { name: "auth",         path: "auth",         dockerfile: "auth/Dockerfile" }
          - { name: "anime-search", path: "anime-search", dockerfile: "anime-search/Dockerfile" }
    steps:
      - uses: actions/checkout@v4

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.OWNER }}/${{ matrix.service.name }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=sha-,format=short
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.title=${{ matrix.service.name }}

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.OWNER }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.service.path }}
          file: ${{ matrix.service.dockerfile }}
          push: ${{ github.event_name != 'pull_request' }}
          platforms: linux/amd64
          build-args: |
            CGO_ENABLED=${{ env.CGO_ENABLED }}
            GOOS=${{ env.GOOS }}
            GOARCH=${{ env.GOARCH }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          sbom: true
          provenance: mode=min
          labels: ${{ steps.meta.outputs.labels }}
          tags: ${{ steps.meta.outputs.tags }}

  tag-latest:
    name: Tag :latest
    needs: [ docker ]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: [ "users", "auth", "anime-search" ]
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Retag to :latest and push
        run: |
          SRC="ghcr.io/${{ github.repository_owner }}/${{ matrix.image }}:sha-$(echo $GITHUB_SHA | cut -c1-7)"
          DEST="ghcr.io/${{ github.repository_owner }}/${{ matrix.image }}:latest"
          docker pull "$SRC"
          docker tag "$SRC" "$DEST"
          docker push "$DEST"

  deploy:
   name: Deploy to VPS (Vault)
   needs: [ tag-latest ]
   if: github.ref == 'refs/heads/main'
   runs-on: ubuntu-latest
   env:
    VPS_DIR: ${{ secrets.VPS_ROOT_DIR }}
    GHCR_USER: ${{ secrets.GHCR_USER }}
    GHCR_PAT: ${{ secrets.GHCR_PAT }}
   steps:
    - uses: actions/checkout@v4

    - name: Auth to Vault via OIDC
      uses: hashicorp/vault-action@v3
      with:
        method: jwt
        url: ${{ secrets.VAULT_ADDR }}
        role: ${{ secrets.VAULT_ROLE }}
        exportToken: true

    - name: Read users secrets
      id: users_kv
      uses: hashicorp/vault-action@v3
      with:
        url: ${{ secrets.VAULT_ADDR }}
        token: ${{ env.VAULT_TOKEN }}
        secrets: |
          kv/data/microservices-planner/users DB_HOST | USERS_DB_HOST ;
          kv/data/microservices-planner/users DB_PORT | USERS_DB_PORT ;
          kv/data/microservices-planner/users DB_USER | USERS_DB_USER ;
          kv/data/microservices-planner/users DB_PASSWORD | USERS_DB_PASSWORD ;
          kv/data/microservices-planner/users DB_NAME | USERS_DB_NAME ;
          kv/data/microservices-planner/users DB_SSLMODE | USERS_DB_SSLMODE ;
          kv/data/microservices-planner/users HTTP_PORT | USERS_HTTP_PORT ;
          kv/data/microservices-planner/users GRPC_PORT | USERS_GRPC_PORT

    - name: Read auth secrets
      id: auth_kv
      uses: hashicorp/vault-action@v3
      with:
        url: ${{ secrets.VAULT_ADDR }}
        token: ${{ env.VAULT_TOKEN }}
        secrets: |
          kv/data/microservices-planner/auth DB_HOST | AUTH_DB_HOST ;
          kv/data/microservices-planner/auth DB_PORT | AUTH_DB_PORT ;
          kv/data/microservices-planner/auth DB_USER | AUTH_DB_USER ;
          kv/data/microservices-planner/auth DB_PASSWORD | AUTH_DB_PASSWORD ;
          kv/data/microservices-planner/auth DB_NAME | AUTH_DB_NAME ;
          kv/data/microservices-planner/auth DB_SSLMODE | AUTH_DB_SSLMODE ;
          kv/data/microservices-planner/auth HTTP_PORT | AUTH_HTTP_PORT ;
          kv/data/microservices-planner/auth GRPC_PORT | AUTH_GRPC_PORT

    - name: Read anime-search secrets
      id: anime_kv
      uses: hashicorp/vault-action@v3
      with:
        url: ${{ secrets.VAULT_ADDR }}
        token: ${{ env.VAULT_TOKEN }}
        secrets: |
          kv/data/microservices-planner/anime-search DB_HOST | ANIME_DB_HOST ;
          kv/data/microservices-planner/anime-search DB_PORT | ANIME_DB_PORT ;
          kv/data/microservices-planner/anime-search DB_USER | ANIME_DB_USER ;
          kv/data/microservices-planner/anime-search DB_PASSWORD | ANIME_DB_PASSWORD ;
          kv/data/microservices-planner/anime-search DB_NAME | ANIME_DB_NAME ;
          kv/data/microservices-planner/anime-search DB_SSLMODE | ANIME_DB_SSLMODE ;
          kv/data/microservices-planner/anime-search HTTP_PORT | ANIME_HTTP_PORT ;
          kv/data/microservices-planner/anime-search GRPC_PORT | ANIME_GRPC_PORT ;
          kv/data/microservices-planner/anime-search API_KEY | ANIME_API_KEY

    - name: Upload compose
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT }}
        source: docker-compose.prod.yml
        target: ${{ env.VPS_DIR }}
        strip_components: 0

    - name: Write env and deploy
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT }}
        envs: OWNER,VPS_DIR,GHCR_USER,GHCR_PAT
        script_stop: true
        script: |
          set -euo pipefail
          if [ -z "${VPS_DIR:-}" ]; then
            echo "VPS_DIR is empty. Set secret VPS_ROOT_DIR, e.g. /opt/microservices-planner" >&2
            exit 1
          fi
          export OWNER="${OWNER:-${{ github.repository_owner }}}"
          mkdir -p "$VPS_DIR/env"
          cd "$VPS_DIR"

          cat > env/users.env <<'EOF'
          DB_HOST=${{ steps.users_kv.outputs.USERS_DB_HOST }}
          DB_PORT=${{ steps.users_kv.outputs.USERS_DB_PORT }}
          DB_USER=${{ steps.users_kv.outputs.USERS_DB_USER }}
          DB_PASSWORD=${{ steps.users_kv.outputs.USERS_DB_PASSWORD }}
          DB_NAME=${{ steps.users_kv.outputs.USERS_DB_NAME }}
          DB_SSLMODE=${{ steps.users_kv.outputs.USERS_DB_SSLMODE }}
          HTTP_PORT=${{ steps.users_kv.outputs.USERS_HTTP_PORT }}
          GRPC_PORT=${{ steps.users_kv.outputs.USERS_GRPC_PORT }}
          EOF

          cat > env/auth.env <<'EOF'
          DB_HOST=${{ steps.auth_kv.outputs.AUTH_DB_HOST }}
          DB_PORT=${{ steps.auth_kv.outputs.AUTH_DB_PORT }}
          DB_USER=${{ steps.auth_kv.outputs.AUTH_DB_USER }}
          DB_PASSWORD=${{ steps.auth_kv.outputs.AUTH_DB_PASSWORD }}
          DB_NAME=${{ steps.auth_kv.outputs.AUTH_DB_NAME }}
          DB_SSLMODE=${{ steps.auth_kv.outputs.AUTH_DB_SSLMODE }}
          HTTP_PORT=${{ steps.auth_kv.outputs.AUTH_HTTP_PORT }}
          GRPC_PORT=${{ steps.auth_kv.outputs.AUTH_GRPC_PORT }}
          EOF

          cat > env/anime-search.env <<'EOF'
          DB_HOST=${{ steps.anime_kv.outputs.ANIME_DB_HOST }}
          DB_PORT=${{ steps.anime_kv.outputs.ANIME_DB_PORT }}
          DB_USER=${{ steps.anime_kv.outputs.ANIME_DB_USER }}
          DB_PASSWORD=${{ steps.anime_kv.outputs.ANIME_DB_PASSWORD }}
          DB_NAME=${{ steps.anime_kv.outputs.ANIME_DB_NAME }}
          DB_SSLMODE=${{ steps.anime_kv.outputs.ANIME_DB_SSLMODE }}
          HTTP_PORT=${{ steps.anime_kv.outputs.ANIME_HTTP_PORT }}
          GRPC_PORT=${{ steps.anime_kv.outputs.ANIME_GRPC_PORT }}
          API_KEY=${{ steps.anime_kv.outputs.ANIME_API_KEY }}
          EOF

          cat > env/users-db.env <<'EOF'
          POSTGRES_DB=${{ steps.users_kv.outputs.USERS_DB_NAME }}
          POSTGRES_USER=${{ steps.users_kv.outputs.USERS_DB_USER }}
          POSTGRES_PASSWORD=${{ steps.users_kv.outputs.USERS_DB_PASSWORD }}
          EOF

          chmod 600 env/*.env

          if [ -n "${GHCR_USER:-}" ] && [ -n "${GHCR_PAT:-}" ]; then
            echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
          fi

          docker compose -f docker-compose.prod.yml pull
          docker compose -f docker-compose.prod.yml up -d --remove-orphans
          docker image prune -f
